reactive 最基础的功能，把一个对象封装成响应式对象。
核心的函数：
Proxy（target, handler）  
参数: target, 代理对象。
		handler 在代理对象出现变动的时候，可以触发的操作函数， 
		如 get ,set ,del 等
流程： reactive() -> 创建 createReactiveObject 
```
const obj =  {foo：1 , bar : { cc : 2 }}
const get = createGetter() 
const set = createSetter()

// 最大依赖储存。 因为 对象中可能有很多的内容，嵌套，
// 先定义map, 然后把 每一个对象内容以 key= target的形式存储
const targetMap = new Map()

function tarck (target, key) {
	// 取出target
	let depsMap = targetMap.get(target)
	if(!depsMap){
	 // 初始化的时候需要创建一个大的对象 ，存储全部dep，用map
	 depsMap = new Map()
	 targetMap.set(target, depsMap)
	}
	let dep = depsMap.get(key)
	if(!dep) {
	 // 初始化
	 // 不允许有重复的 key值对象，用了 set
	 dep = new Set()
	 depsMap.set(key, dep)
	}
	// 依赖收集
	trackEffect(dep)
}
function trackEffect(dep) {
	 // 防止重复收集依赖.
	 if(dep.has(activeEffect)) return
	 dep.add(activeEffect)
	 activeEffect.deps.push(dep)
}

// 初始化的时候是 get
function createGetter () {
	const res = Reflect.get(traget, key)
	// 收集依赖
	track(traget, key)
	return res
}
// 
function createSetter () {
	// 参数是 basehandlers
	return funciton set (target, key, value) {
		// **Reflect** 是一个内置的对象，它提供拦截 JavaScript 操作的方法。通过 Reflect 去把值设置。
		const res = Reflect.set(traget, key, value)
		// 触发设置，依赖收集
		trigger(target, key)
		return res
	}
}
const basehandlers = { get , set }
 // 初始化的时候创建
function createReactiveObject() {
	
	const proxy  = new Proxy(taget, basehandlers)
}


// update 触发。

export function trigger (target, key){

 let depsMap = targetMap.get(target)

 let dep = depsMap.get(key)

 triggerEffects(dep)

}

  

export function triggerEffects (dep) {


 for(const effect of dep) {

 if(effect.scheduler){

 effect.scheduler()

 }else{

 effect.run()

 }

 }

}
```