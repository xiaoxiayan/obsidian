reactive 最基础的功能，把一个对象封装成响应式对象。
核心的函数：
Proxy（target, handler）  
参数: target, 代理对象。
		handler 在代理对象出现变动的时候，可以触发的操作函数， 
		如 get ,set ,del 等
思路流程图：
![[reactivity 依赖收集.png]]

 reactive() -> 创建 createReactiveObject()
```


// 最大依赖储存。 因为 对象中可能有很多的内容，嵌套，
// 先定义map, 然后把 每一个对象内容以 key= target的形式存储
const targetMap = new Map()
const get = createGetter() 
const set = createSetter()
const basehandlers = { get , set }
 // 初始化的时候创建
function createReactiveObject() {
	const proxy  = new Proxy(taget, basehandlers)
}
// 初始化的时候是 get
function createGetter () {
	const res = Reflect.get(traget, key)
	// 收集依赖
	track(traget, key)
	return res
}
// 
function createSetter () {
	// 参数是 basehandlers
	return funciton set (target, key, value) {
		// **Reflect** 是一个内置的对象，它提供拦截 JavaScript 操作的方法。通过 Reflect 去把值设置。
		const res = Reflect.set(traget, key, value)
		// 触发update，依赖收集
		trigger(target, key)
		return res
	}
} 

```
获取到  fn ： 创建一个类，定义一个全局变量去收集当前的 fn
```
// 全局变量
let activeEffect;
export class ReactiveEffect {
 private _fn: any
 deps = []
 constructor(fn, public ){
	 this._fn = fn
 }
 run() {
	 // 收集依赖
	 activeEffect = this
	 // 执行fn
	 this._fn() 
 }
}

// 依赖收集
export function effect (fn, options:any = {}) {
 const _effect = new ReactiveEffect(fn, options.scheduler)
 _effect.run()
}
```

触发依赖收集 ：
```
function tarck (target, key) {
	// 取出target
	let depsMap = targetMap.get(target)
	if(!depsMap){
	 // 初始化的时候需要创建一个大的对象 ，存储全部dep，用map
	 depsMap = new Map()
	 targetMap.set(target, depsMap)
	}
	let dep = depsMap.get(key)
	if(!dep) {
	 // 初始化
	 // 不允许有重复的 key值对象，用了 set
	 dep = new Set()
	 depsMap.set(key, dep)
	}
	// 依赖收集
	trackEffect(dep)
}

function trackEffect(dep) {
	 // 防止重复收集依赖.
	 if(dep.has(activeEffect)) return
	 dep.add(activeEffect)
}

```
触发update :
```
// update 触发。
export function trigger (target, key){
 let depsMap = targetMap.get(target)
 let dep = depsMap.get(key)
 triggerEffects(dep)
}
function triggerEffects (dep) {
	for(effect of dep) {
		effect.run()
	}
}

```
