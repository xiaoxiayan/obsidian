使用递增序列确定出一个固定的序列 （返回的是 数组中的 index）。操作其他的 节点。
new array  一个数组 newIndexToOldIndexMap，长度为 toBePatched ,来映新的节点在旧的节点中对应的 index。
newIndexToOldIndexMap 在 oldArr 循环中 赋值为  i + 1   
i + 1 是为了 解决 初始化为 0， 节点在 0 号的问题，也为了新增做铺垫。
然后  getSequence 找出 最长子序列 increasingNewIndexSequence，找到不需要移动的点 index
倒叙的去 处理节点，因为锚点的插入需要一个稳定的元素
循环 长度， 需要处理的 节点长度。
对比，如果   i  存在于  最长子序列中 ，说明不需要移动。子序列 往前走，否则移动。

应对的是 patchChildren 中 ，ArrayToArray 优化计算处理，减少dom 的消耗。
分为以下几种情况
1、左侧的对比，新的比老的多，在右侧。
// (a b) c
// (a b) d e
需要三个指针， i : 从0 开始，e1,  e2 , 从后面开始
patchKeyChildren(c1, c2 ,container, parentComponent) {
  let i = 0;
  let e1 = c1.length -1 
  let e2 = c2.length -1
  
}





